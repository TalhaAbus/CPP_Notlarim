# C++ dilinin keywords'leri nelerdir

C++ dilinin anahtar kelimeleri (keywords) şunlardır:

- alignas: Değişkenlerin hafıza hizalamasını kontrol etmek için kullanılır.
- alignof: Bir türün hafıza hizalamasını döndürür.
- and: Mantıksal VE işlemi için kullanılır.
- and_eq: Bit düzeyinde AND işlemi ve sonucunu atamak için kullanılır.
- asm: Assembler kodunu içeren bir blok yazmak için kullanılır.
- auto: Otomatik tür belirleme için kullanılır.
- bitand: Bit düzeyinde AND işlemi için kullanılır.
- bitor: Bit düzeyinde OR işlemi için kullanılır.
- bool: Boolean türü için kullanılır.
- break: Döngü veya switch ifadesinden çıkmak için kullanılır.
- case: Switch ifadesindeki bir seçenek için kullanılır.
- catch: Bir hata yakalamak için kullanılır.
- char: Karakter türü için kullanılır.
- char16_t: 16-bit Unicode karakter türü için kullanılır.
- char32_t: 32-bit Unicode karakter türü için kullanılır.
- class: Bir sınıf tanımlamak için kullanılır.
- compl: Bit düzeyinde ters işlemi için kullanılır.
- const: Değişkenin sabit olduğunu belirtmek için kullanılır.
- constexpr: Derleme zamanı sabitleri için kullanılır.
- const_cast: Bir değişkenin sabitliğini kaldırmak için kullanılır.
- continue: Döngünün sonraki adımına atlamak için kullanılır.
- decltype: Bir ifadenin türünü belirlemek için kullanılır.
- default: Switch ifadesindeki varsayılan seçeneği belirtmek için kullanılır.
- delete: Bir sınıf üyesinin veya işlevinin silinmesi için kullanılır.
- do: Bir döngünün başlatılması için kullanılır.
- double: Çift hassasiyetli kayan nokta türü için kullanılır.
- dynamic_cast: Bir nesnenin türünü dönüştürmek için kullanılır.
- else: If ifadesindeki bir alternatif seçeneği için kullanılır.
- enum: Bir numaralandırma türü tanımlamak için kullanılır.
- explicit: Belli bir türden yapısal dönüşümü engellemek için kullanılır.
- export: Bir fonksiyonun veya veri yapısının başka bir modülden kullanılmasına izin vermek için kullanılır.
- extern: Bir değişkenin veya fonksiyonun başka bir dosyada tanımlandığını belirtmek için kullanılır.
- false: Boolean değeri yanlış olarak belirtmek için kullanılır.
- float: Tek hassasiyetli kayan nokta türü için kullanılır.
- for: Bir döngünün başlatılması
- friend: Bir sınıfın özel üyelerine erişim izni vermek için kullanılır.
- goto: Etiketlenmiş bir yere atlamak için kullanılır.
- if: Koşullu bir ifadeyi başlatmak için kullanılır.
- inline: İşlevlerin hızlı bir şekilde çağrılmasını sağlamak için kullanılır.
- int: Tamsayı türü için kullanılır.
- long: Uzun tamsayı türü için kullanılır.
- mutable: Bir const nesnesinin içeriğinin değiştirilebileceğini belirtmek için kullanılır.
- namespace: Bir ad alanı tanımlamak için kullanılır.
- new: Bellek tahsisi için kullanılır.
- noexcept: İşlevin istisna fırlatmayacağını belirtmek için kullanılır.
- not: Mantıksal DEĞİL işlemi için kullanılır.
- not_eq: Bit düzeyinde XOR işlemi ve sonucunu atamak için kullanılır.
- nullptr: Null işaretçisi için kullanılır.
- operator: Bir operatörü yeniden tanımlamak için kullanılır.
- or: Mantıksal VEYA işlemi için kullanılır.
- or_eq: Bit düzeyinde OR işlemi ve sonucunu atamak için kullanılır.
- private: Bir sınıfın özel üyelerini belirlemek için kullanılır.
- protected: Bir sınıfın korunan üyelerini belirlemek için kullanılır.
- public: Bir sınıfın genel üyelerini belirlemek için kullanılır.
- register: Kaydedilen bir değişkenin daha hızlı erişim için optimize edilmesini sağlar.
- reinterpret_cast: Bir nesnenin türünü başka bir türe dönüştürmek için kullanılır.
- return: İşlevden çıkış yapmak için kullanılır.
- short: Kısa tamsayı türü için kullanılır.
- signed: Tamsayı türünün işaretli olduğunu belirtmek için kullanılır.
- sizeof: Bir türün bellek boyutunu döndürür.
- static: Bir sınıf veya değişkenin yalnızca bir kez tanımlanacağını belirtmek için kullanılır.
- static_assert: Derleme zamanında bir koşulu kontrol etmek için kullanılır.
- static_cast: Bir nesnenin türünü başka bir türe dönüştürmek için kullanılır.
- struct: Bir yapı tanımlamak için kullanılır.
- switch: Birden fazla seçenek arasında seçim yapmak için kullanılır.
- template: Bir şablon işlevi veya sınıfı tanımlamak için kullanılır.
- this: Bir sınıfın bir üyesine erişmek için kullanılır.
- throw: Bir hata fırlatmak için kullanılır.
- true: Boolean değeri doğru olarak
- try: Bir hata durumunun ele alınması için kullanılır.
- typedef: Yeni bir tür tanımlamak için kullanılır.
- typeid: Bir nesnenin türünü döndürür.
- typename: Bir şablon tür parametresinin bir tür olduğunu belirtmek için kullanılır.
- union: Bir birleşim tanımlamak için kullanılır.
- unsigned: Tamsayı türünün işaretsiz olduğunu belirtmek için kullanılır.
- using: Bir ismi veya bir ad alanını kısaltmak için kullanılır.
- virtual: Sanal bir işlev tanımlamak veya çağırmak için kullanılır.
- void: Herhangi bir tür olmadığını belirtmek için kullanılır.
- volatile: Değişkenin beklenmedik şekilde değişebileceğini belirtmek için kullanılır.
- wchar_t: Genişletilmiş karakter kümesi türü için kullanılır.

# basic_string_view ve basic_string nedir?

- std::basic_string ve std::basic_string_view, C++'ta metin işleme işlevlerini gerçekleştirmek için kullanılan iki sınıftır.
- std::basic_string sınıfı, metinleri depolamak, değiştirmek ve erişmek için kullanılır. Bu sınıf, dinamik olarak yeniden boyutlandırılabilen bir dizi (yani bir dize) tutar. 
- std::basic_string_view sınıfı ise, bir std::basic_string örneğine bakılmaksızın bir karakter dizisine (metne) bakmak için kullanılır.

- Kullanılacak sınıf, kullanım senaryonuza bağlıdır. Eğer metni değiştirmeniz gerekiyorsa 

> std::basic_string kullanmalısınız. Eğer metni sadece okumak istiyorsanız,

> std::basic_string_view kullanabilirsiniz. std::basic_string_view, std::basic_string sınıfına göre daha hafif bir veri yapısıdır ve performansı daha yüksektir. Ancak, 

> std::basic_string_view nesnesi, kendisine atanan karakter dizisi ömrü boyunca geçerli olmalıdır. Aksi takdirde, tanımsız davranışa yol açabilir.

**std::basic_string Örneği:**

```CPP
#include <iostream>
#include <string>

int main() {
  std::string str = "Merhaba dünya!"; // bir string tanımlıyoruz
  std::cout << "string: " << str << std::endl; // çıktı: string: Merhaba dünya!
  
  str.replace(0, 7, "Selam"); // string içindeki "Merhaba"yı "Selam" ile değiştiriyoruz
  std::cout << "string: " << str << std::endl; // çıktı: string: Selam dünya!
  
  return 0;
}

```
**std::basic_string_view Örneği:**

```CPP
#include <iostream>
#include <string_view>

int main() {
  std::string_view str = "Merhaba dünya!"; // bir string_view tanımlıyoruz
  std::cout << "string_view: " << str << std::endl; // çıktı: string_view: Merhaba dünya!
  
  std::string_view greeting = str.substr(0, 7); // "Merhaba"yı greeting adlı yeni bir string_view'a kopyalıyoruz
  std::cout << "greeting: " << greeting << std::endl; // çıktı: greeting: Merhaba
  
  return 0;
}

```

- Yukarıdaki örneklerde, önce std::string ve sonra std::string_view kullanarak farklı işlemler gerçekleştiriyoruz. std::string ile bir metin değiştirme işlemi yapıyoruz ve std::string_view ile bir alt dize kopyalama işlemi yapıyoruz.

- substr() yöntemi, std::basic_string ve std::basic_string_view sınıflarında bulunan bir yöntemdir ve bir alt dize oluşturmak için kullanılır.
- Yukarıdaki örnekte, substr() yöntemini kullanarak, önceden tanımlanmış bir std::string_view örneğinden bir alt dize kopyalıyoruz. İlk parametre, alt dize oluşturulacak karakterlerin başlangıç konumunu, ikinci parametre ise kaç karakterin kopyalanacağını belirtir.
- Yani str.substr(0, 7) ifadesi, str string_view'unda ilk karakterden itibaren 7 karakteri içeren bir alt dize oluşturur. Bu alt dize, greeting adlı yeni bir std::string_view nesnesine kopyalanır ve sonunda greeting alt dizisi "Merhaba" değerine sahip olur.
- Evet, son örnekte std::string_view yerine std::string kullanabilirsiniz. std::string sınıfı, std::string_view sınıfının tamamını kapsar, yani std::string nesneleri, metnin tamamını saklayabilir ve ayrıca substr() yöntemini de destekler.

- Aşağıda, son örneğin std::string kullanarak değiştirilmiş bir versiyonu bulunmaktadır:

```CPP
#include <iostream>
#include <string>

int main() {
  std::string str = "Merhaba dünya!"; // bir string tanımlıyoruz
  std::cout << "string: " << str << std::endl; // çıktı: string: Merhaba dünya!
  
  std::string greeting = str.substr(0, 7); // "Merhaba"yı greeting adlı yeni bir string'e kopyalıyoruz
  std::cout << "greeting: " << greeting << std::endl; // çıktı: greeting: Merhaba
  
  return 0;
}

```

- Yukarıdaki örnekte, önceki örnekteki kodu aynen kullandık, ancak sadece std::string_view yerine std::string kullanarak değişkenleri tanımladık. Buna göre, substr() yöntemini std::string üzerinde kullanarak, str değişkenindeki bir alt dizeyi greeting adlı yeni bir std::string nesnesine kopyaladık

# eğer strıng sınıfı string_view sınıfını tamamen kapsıyorsa, bunların hangisini kullanmalıyız

- Bu durumda, kullanmanız gereken sınıf, işlevselliğe ve performansa bağlı olarak değişebilir.

- std::string sınıfı, tam bir metin verisini depolayabilir ve değiştirebilirsiniz. Ancak, bu durumda bellek kullanımı ve işlemci zamanı açısından maliyetlidir.

- std::string_view sınıfı, bellek kullanımını azaltır ve performansı artırır. Ancak, bir std::string_view örneği, kendisine atanan karakter dizisi ömrü boyunca geçerli olmalıdır. Aksi takdirde, tanımsız davranışa yol açabilir.

- Yani, eğer bir metni değiştirmeniz gerekiyorsa veya bir metin üzerinde işlem yapacaksanız, std::string sınıfını kullanmalısınız. Ancak, bir metni sadece okuyacaksanız ve bellek kullanımınızı minimize etmek istiyorsanız, std::string_view sınıfını kullanabilirsiniz.

- Ayrıca, bir std::string nesnesini std::string_view nesnesine veya tam tersine dönüştürmek için kullanışlı yöntemler de bulunmaktadır. std::string sınıfındaki c_str() yöntemi, std::string nesnesini bir const char* türünde bir işaretçiye dönüştürürken, std::string_view sınıfındaki std::string_view(std::string) dönüştürücü yapıcı, bir std::string nesnesini std::string_view nesnesine dönüştürür.

# string sınıfını bana detaylıca öğretir misin?

- Tabii, std::string sınıfını ayrıntılı bir şekilde açıklayabilirim. İşte std::string sınıfı hakkında bilmeniz gerekenler:

- std::string, C++ standart kütüphanesinde yer alan bir sınıftır ve metin verilerini depolamak için kullanılır. Bu sınıf, dinamik olarak yeniden boyutlandırılabilen bir dizi (yani bir dize) tutar.

- std::string, C tarzı karakter dizileri (char dizileri) gibi davranır ve temel olarak bir karakter dizisi işlevi görür. Ancak, std::string sınıfı C tarzı dizilerden farklı olarak, metnin uzunluğunu izler ve metin uzunluğu değiştikçe otomatik olarak yeniden boyutlandırılabilir.

- std::string sınıfı, C++'ın modern bellek yönetimini kullanarak, dize işlemlerini hızlı ve verimli bir şekilde gerçekleştirir. Bu sınıf ayrıca, birçok kullanışlı yöntem sağlar ve metin verileri üzerinde birçok işlem yapmanıza izin verir.

- İşte std::string sınıfı tarafından sağlanan bazı kullanışlı yöntemler:

- size(): Dizideki karakter sayısını döndürür.
- length(): Dizideki karakter sayısını döndürür.
- empty(): Dizinin boş olup olmadığını belirler.
- clear(): Diziyi temizler (boşaltır).
- push_back(): Dizinin sonuna bir karakter ekler.
- append(): Diziye bir karakter dizisi ekler.
- replace(): Dizideki bir alt dizeyi başka bir alt dize ile değiştirir.
- substr(): Dizideki bir alt dizeyi alır.
- find(): Belirtilen karakter veya alt dizenin konumunu döndürür.

- Ayrıca, std::string sınıfı, birçok operatöre de sahiptir. Bu operatörler şunları içerir:
- +: İki dizeyi birleştirir.
- ==, !=, <, >, <=, >=: Dizileri karşılaştırır.

- İşte birkaç örnek kullanım:

```CPP
#include <iostream>
#include <string>

int main() {
  std::string greeting = "Merhaba";
  std::string name = "Ali";
  std::string message = greeting + " " + name + "!"; // "Merhaba Ali!" oluşturur
  std::cout << message << std::endl;
  
  std::string sentence = "Bu bir örnek cümledir.";
  std::string word = sentence.substr(3, 3); // "bir" oluşturur
  std::cout << word << std::endl;
  
  return 0;
}

```

# typeid kullanımına örnek ver

- typeid operatörü, bir nesnenin türünü veya bir türün tür bilgisini döndürür. Bu operatör, dinamik tür belirleme veya RTTI (Run-Time Type Identification) için kullanılır.

- İşte bir typeid örneği:

```CPP
#include <iostream>
#include <typeinfo>

class Base {
 public:
  virtual ~Base() {}
};

class Derived : public Base {};

int main() {
  Base* b = new Derived();
  if (typeid(*b) == typeid(Derived)) {
    std::cout << "b, Derived türüne sahiptir." << std::endl;
  }
  delete b;

  return 0;
}

```

- Yukarıdaki örnekte, Base sınıfı ve Derived sınıfı tanımlanmıştır. Daha sonra, Base sınıfının bir işaretçisi, Derived sınıfının bir örneğiyle oluşturulur.

- typeid operatörü, *b ifadesini kullanarak, b işaretçisinin gösterdiği nesnenin türünü belirler. Bu tür, Derived sınıfıdır. typeid operatörü, bu türü, Derived türü ile karşılaştırır. Eğer türler eşitse, b işaretçisi Derived sınıfına sahiptir ve "b, Derived türüne sahiptir." çıktısı verilir.

- Bu örnek, dinamik tür belirleme için kullanılan typeid operatörünü göstermektedir.

# Sınıfın destructor unu nasıl virtual yaptın?

- Sınıfın destructor'ını sanal yapmak, miras alınan sınıfların nesneleri silerken doğru destructor'ın çağrılmasını sağlamak için önemlidir. C++ dilinde, bir sınıfın sanal destructor'ı, bazı sınıf üyeleri gibi özel bir türdedir ve aşağıdaki şekilde tanımlanır:

```CPP
class Base {
 public:
  virtual ~Base() {}
};

```

- Burada ~Base() fonksiyonu sanal ve boş bir uygulamaya sahiptir. Sanal destructor'lar, tüm kalıtılan sınıfların destructor'larının sanal olduğu sürece çalışır.

- Sanal destructor, sınıfın türetilmiş sınıflarında kullanıldığında, sanal destructor'ı silmek için delete operatörünün kullanılmasını sağlar. Ayrıca, bir sınıfın sanal destructor'ını belirtmek, o sınıfın türetilmiş sınıfları tarafından bellek sızıntısı olmaksızın yok edilmesini sağlar.

- İşte bir örnek:

```CPP
#include <iostream>

class Base {
 public:
  virtual ~Base() {
    std::cout << "Base destructor çağrıldı." << std::endl;
  }
};

class Derived : public Base {
 public:
  ~Derived() {
    std::cout << "Derived destructor çağrıldı." << std::endl;
  }
};

int main() {
  Base* b = new Derived();
  delete b;

  return 0;
}

```
- Yukarıdaki örnekte, Base sınıfı ve Derived sınıfı tanımlanmıştır. Base sınıfının destructor'ı sanal olarak belirtilmiştir. Derived sınıfının destructor'ı, özel olarak tanımlanmıştır.

- main() fonksiyonunda, Base sınıfının bir işaretçisi, Derived sınıfının bir örneğiyle oluşturulur. Daha sonra, delete operatörü kullanılarak b işaretçisinin işaret ettiği nesne silinir.

- Bu örnekte, Base ve Derived sınıflarının destructor'ları çağrılır. Base sınıfının destructor'ı sanal olarak belirtilmiş olduğundan, Derived sınıfının destructor'ı çağrıldıktan sonra Base sınıfının destructor'ı da çağrılır. Bu, türetilmiş sınıfların doğru bir şekilde temizlendiğini ve bellek sızıntısının önlenildiğini sağlar.

# decltype kullanımına örnek ver

- decltype operatörü, bir ifade veya değişkenin türünü belirlemek için kullanılır. Bu operatör, derleme zamanında tür bilgisine ihtiyaç duyduğumuz durumlarda oldukça kullanışlıdır.

- İşte bir decltype örneği:

```CPP
#include <iostream>
#include <typeinfo>

int main() {
  int x = 42;
  const int& rx = x;
  auto ax = x;
  decltype(rx) arx = x;
  decltype(ax) aax = x;

  std::cout << typeid(rx).name() << std::endl;
  std::cout << typeid(arx).name() << std::endl;
  std::cout << typeid(aax).name() << std::endl;

  return 0;
}

```
- Yukarıdaki örnekte, bir int türünden x değişkeni tanımlanır. Daha sonra, const int& türünden bir referans rx oluşturulur ve x'e atanır. auto anahtar sözcüğü kullanılarak, ax isimli bir değişken x'e eşitlenir.

- decltype operatörü, rx ve ax değişkenlerinin türlerini belirlemek için kullanılır. arx değişkeni, rx referansı türünden decltype(rx) kullanılarak oluşturulur. aax değişkeni ise ax türünden decltype(ax) kullanılarak oluşturulur.

- Son olarak, typeid işlevi kullanılarak, rx, arx ve aax değişkenlerinin türleri ekrana yazdırılır. Bu örnek, decltype operatörünün nasıl kullanılacağını göstermektedir.

# decltype yerine typeid kullanaiblir miyim??

- decltype ve typeid operatörleri farklı amaçlar için kullanılır ve birbirlerinin yerine kullanılamazlar.

- decltype, bir ifade veya değişkenin türünü belirlemek için kullanılır ve bu tür bilgisini derleme zamanında sağlar. decltype operatörü, derleyici tarafından çözümlenir ve derleme zamanında belirlenen tür bilgisine dayanır.

- Öte yandan, typeid operatörü, bir nesnenin tür bilgisini çalışma zamanında elde etmek için kullanılır. typeid operatörü, bir nesnenin dinamik türünü belirlemek için kullanılır. Çalışma zamanında, typeid operatörü, nesnenin türünün bilgisini belirler.

- Bu nedenle, decltype ve typeid operatörleri farklı amaçlar için kullanılır ve birbirlerinin yerine kullanılamazlar. Eğer bir ifade veya değişkenin tür bilgisine ihtiyacınız varsa, decltype operatörünü kullanmalısınız. Eğer bir nesnenin tür bilgisine ihtiyacınız varsa, typeid operatörünü kullanmalısınız.

# yani decltype derleme zamanına, typeid çalışma zamanına yönelik mi kullanılıyor

- Evet, doğru anlamışsınız. decltype operatörü derleme zamanında kullanılan bir operatördür. decltype operatörü, bir ifadenin türünü derleme zamanında belirlemek için kullanılır.

- typeid operatörü ise çalışma zamanında kullanılan bir operatördür. typeid operatörü, bir nesnenin dinamik türünü belirlemek için çalışma zamanında kullanılır.

- İki operatör de farklı amaçlar için kullanıldığından ve farklı tür bilgisi sağladığından, birbirlerinin yerine kullanılamazlar. decltype operatörü, derleme zamanında kullanıldığı için, sabit bir tür bilgisi sağlar. typeid operatörü ise çalışma zamanında kullanıldığı için, dinamik olarak belirlenen tür bilgisini sağlar.

# final keyword nedir?

- final anahtar kelimesi, sınıf, fonksiyon veya sanal fonksiyonlar üzerinde kullanılarak, türetilmiş sınıfların bu öğeleri yeniden tanımlamasını önleyen bir özelliktir.

- final anahtar kelimesi, nesne yönelimli programlama ile ilgili bir kavram olan "polimorfizm"i destekler. Polimorfizm, bir nesnenin birden fazla türle ilişkilendirilebileceği bir özelliktir. Bu nedenle, bir nesnenin davranışı, o nesnenin türüne bağlı olarak değişebilir.

- final anahtar kelimesi, türetilmiş sınıfların belirli bir sınıfın özelliklerini veya işlevselliğini değiştirmesini engellemek için kullanılır. Bir sınıfın final anahtar kelimesiyle işaretlenmiş olması, bu sınıftan türetilmiş sınıfların, bu sınıfın işlevselliğini veya özelliklerini değiştiremeyeceği anlamına gelir.

- İşte bir örnek:

```CPP
#include <iostream>

class Base {
 public:
  virtual void foo() final {
    std::cout << "Base::foo() çalıştı." << std::endl;
  }
};

class Derived : public Base {
 public:
  // "error: virtual function 'Base::foo' has been marked final"
  // void foo() override {}
};

int main() {
  Base b;
  b.foo();

  return 0;
}

```
- Yukarıdaki örnekte, Base sınıfı tanımlanmış ve foo() sanal fonksiyonu final anahtar kelimesi ile işaretlenmiştir. Bu nedenle, Base sınıfından türetilen sınıflar, foo() fonksiyonunu yeniden tanımlayamazlar.

- Derived sınıfı, Base sınıfından türetilmiştir ve foo() fonksiyonunu yeniden tanımlamaya çalışır. Ancak, foo() fonksiyonu final anahtar kelimesi ile işaretlendiği için, Derived sınıfı derleme hatası verir.

- Bu örnekte, final anahtar kelimesinin kullanımı, türetilmiş sınıfların belirli bir sınıfın işlevselliğini veya özelliklerini değiştirmesini engeller.

# std::swap nedir?

- std::swap C++ Standard Library'de tanımlanmış bir fonksiyondur ve iki nesnenin yerlerini değiştirir. std::swap fonksiyonu, iki nesnenin aynı türde olması koşuluyla, herhangi bir tür için kullanılabilir.

- std::swap fonksiyonu, iki nesne arasında değerlerin yer değiştirmesi işlemini gerçekleştirir. Bu işlem, std::swap fonksiyonu tarafından özel olarak tanımlanmış bir algoritma kullanılarak gerçekleştirilir. std::swap fonksiyonu, değerleri kopyalamak yerine nesnelerin bellek bölgelerini değiştirir ve bu nedenle büyük nesnelerin yer değiştirilmesi için daha hızlı bir yöntem sağlar.

- İşte bir örnek:

```CPP
#include <iostream>
#include <utility>

int main() {
  int x = 10;
  int y = 20;

  std::cout << "x = " << x << ", y = " << y << std::endl;

  std::swap(x, y);

  std::cout << "x = " << x << ", y = " << y << std::endl;

  return 0;
}

```

- Yukarıdaki örnekte, std::swap fonksiyonu kullanılarak x ve y değişkenleri yer değiştirilir. İlk olarak, x ve y değişkenlerinin değerleri ekrana yazdırılır. Daha sonra, std::swap fonksiyonu kullanılarak x ve y değişkenleri yer değiştirilir. Son olarak, x ve y değişkenlerinin yeni değerleri ekrana yazdırılır.

- Bu örnekte, std::swap fonksiyonu, iki nesnenin yer değiştirmesi işlemini gerçekleştirir ve x ve y değişkenlerinin yerlerini değiştirir.

# swap fonksiyonu birçok sınıfın içinde bulunuyor mu?

- Evet, swap fonksiyonu birçok C++ sınıfının içinde veya kütüphanesinde yer alır. C++11 sürümüne kadar, C++ Standard Library'deki sınıfların birçoğu, swap fonksiyonlarını sağlamak için swap adlı bir global fonksiyon kullanıyordu.

- Ancak, C++11 sürümünden itibaren, bir sınıfın swap fonksiyonunu özelleştirmek için swap adlı bir non-member fonksiyon kullanmak önerilir. Bu, sınıfların daha iyi genel kütüphane uyumluluğu sağlamasını ve özelleştirilmiş sınıfların std::swap kullanımını kolaylaştırmasını sağlar.

- Örneğin, std::vector sınıfı, swap fonksiyonunu özelleştirmek için aşağıdaki non-member fonksiyonu kullanır:

```CPP
namespace std {
  template<class T, class Allocator>
  void swap(vector<T, Allocator>& x, vector<T, Allocator>& y) noexcept(noexcept(x.swap(y)));
}

```
- Bu örnekte, std::vector sınıfı, swap fonksiyonunu non-member bir fonksiyon olarak sağlar. std::vector sınıfının swap fonksiyonu, x ve y isimli iki vector nesnesinin yerlerini değiştirir.

- Diğer bir örnek olarak, std::unique_ptr sınıfı, swap fonksiyonunu non-member bir fonksiyon olarak sağlar:

```CPP
namespace std {
  template<class T, class D>
  void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
}

```

- Bu örnekte, std::unique_ptr sınıfı, swap fonksiyonunu non-member bir fonksiyon olarak sağlar. std::unique_ptr sınıfının swap fonksiyonu, x ve y isimli iki unique_ptr nesnesinin yerlerini değiştirir.

- Bu nedenle, birçok C++ sınıfı, swap fonksiyonunu kullanarak nesnelerin yerlerini değiştirir ve std::swap fonksiyonunu kullanarak sınıfın swap fonksiyonu çağrılabilir.



























